dzień 1: 
instalacja vcpkg aby uniknąć problemu z ciągłą zmiana ścieżek biblioteki ASIO przy przechodzeniu z komputera na laptop 

Podział projektu na pliki:
Main.cpp:
	łączy pliki Server.h i Session.h 
	tworzy asio::io_context
	tworzy obiekt Server server(Context,port)
	wywołuje context.run()

Server.h/Server.cpp:
	definicja klasy Server która akceptuje nowych klientów 

Session.h/Session.cpp:
	definicja klasy Session która zarządza połączonym klientem



Dzień 2: Implementacja rdzenia serwera ASIO
Implementacja Server: Poprawnie zaimplementowano konstruktor (inicjalizacja acceptor) oraz asynchroniczną pętlę startAccepting / handleAccept.

Implementacja Session: Stworzono szkielet klasy Session z poprawnym konstruktorem, metodą socket() i start().

Kluczowy problem (rozwiązany): Poprawne użycie funkcji lambda i shared_from_this do obsługi callbacków async_accept (w Server) i async_read_until (w Session).

Kluczowy problem (rozwiązany): Zaimplementowano poprawną logikę pętli czytania w handleRead, w tym rozróżnienie braku błędu, błędu eof (rozłączenie) i innych błędów.

Dodano logikę nicków: Session::handleRead sprawdza teraz, czy pole nick jest puste. Jeśli tak, pierwsza otrzymana wiadomość jest zapisywana jako nick.

Zaimplementowano funkcję Session::parseMessage do parsowania wiadomości w formacie odbiorca:wiadomosc.

Kluczowy problem (Rozwiązany): Zabezpieczono parseMessage przed awarią (wyjściem poza zakres stringa) przez dodanie warunku if (i >= tekst.size()) w pętli while.

Kluczowy problem (Rozwiązany): Naprawiono błąd "race condition" w handleRead przez usunięcie zduplikowanego wywołania async_read_until z bloku if (nick == ""). Pętla czytania jest teraz wywoływana tylko raz na końcu bloku if(!error).




Dzień 3: Implementacja logiki wysyłania (Broadcast i PrivateMessage)

(Połączenie Session z Server): Zaimplementowano przekazywanie referencji Servera (*this) do konstruktora Session. Session (pracownik) ma teraz "telefon" do Servera (centrali) zapisany w polu server_ref_.

(Implementacja Session::write): Stworzono funkcję Session::write do asynchronicznego wysyłania wiadomości.

Kluczowy problem (Rozwiązany): Rozwiązano krytyczny błąd awarii (związany z czasem życia wiadomości) poprzez kopiowanie std::string message do std::shared_ptr i przechwycenie go w lambdzie async_write.

(Implementacja Server::broadcast / send_private): Dodano i zaimplementowano w Server.cpp logikę rozgłaszania do wszystkich (broadcast) oraz wysyłania prywatnego (send_private). Obie funkcje poprawnie iterują po liście active_sessions i wywołują session->write().

(Finał w Session::handleRead): Spięto wszystko razem. Blok else w handleRead (po sprawdzeniu nicku) teraz poprawnie parsuje wiadomość i wywołuje server_ref_.broadcast lub server_ref_.send_private w zależności od adresata.

Stan: Serwer jest w pełni funkcjonalny. Potrafi przyjmować klientów, nadawać nicki, parsować wiadomości (np. All:hej lub Bob:cześć) i poprawnie rozsyłać je do wszystkich lub do konkretnego adresata.


fix 1: Dodano możliwość wypisania Info o dostępnych użytkownikach z nazwa ich nicku, blad podczas kompilacji konstruktor Session oczekuje konkretnego contextu io a funkcja lambda lapie jakikolwiek context



